// src/admin/utils.js
// ============================================================
// Pure utility functions shared across all admin tab modules.
// No React, no side-effects — safe to import anywhere.
// ============================================================

import { PROJECTS, CRITERIA } from "../config";

const PROJECT_MAP = new Map(
  PROJECTS.map((p, i) =>
    typeof p === "string"
      ? [i + 1, { desc: "", students: [] }]
      : [(p.id ?? i + 1), { desc: p.desc ?? "", students: p.students ?? [] }]
  )
);

// ── Numeric coercion ──────────────────────────────────────────
// Strips surrounding quotes (Sheets sometimes wraps numbers in
// quotes) and converts to a finite number, defaulting to 0.
export function toNum(v) {
  const n = Number(
    String(v ?? "").trim().replace(/^"+|"+$/g, "").replace(",", ".")
  );
  return Number.isFinite(n) ? n : 0;
}

// ── Timestamp → milliseconds ──────────────────────────────────
// Priority order:
//   1. ISO 8601 / RFC 2822 — new rows use toISOString(), handled natively.
//   2. EU format: dd/mm/yyyy HH:mm[:ss]
//   3. US format: mm/dd/yyyy [HH:mm[:ss] [AM|PM]]
// Legacy rows stored as locale strings are covered by the regex fallbacks.
export function tsToMillis(ts) {
  if (!ts) return 0;
  const s = String(ts).trim().replace(/\s*,\s*/g, ", ");

  const native = Date.parse(s);
  if (Number.isFinite(native)) return native;

  // EU: dd/mm/yyyy HH:mm[:ss]
  const eu = s.match(
    /^([0-3]?\d)\/([0-1]?\d)\/(\d{4}),?\s*([0-2]?\d):([0-5]\d)(?::([0-5]\d))?$/
  );
  if (eu) {
    return new Date(+eu[3], +eu[2] - 1, +eu[1], +eu[4], +eu[5], +(eu[6] || 0)).getTime() || 0;
  }

  // US: mm/dd/yyyy [HH:mm[:ss] [AM|PM]]
  const us = s.match(
    /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?)?$/i
  );
  if (!us) return 0;
  let h = +(us[4] || 0);
  const ap = (us[7] || "").toUpperCase();
  if (ap === "PM" && h < 12) h += 12;
  if (ap === "AM" && h === 12) h = 0;
  return (
    new Date(+us[3], +us[1] - 1, +us[2], h, +(us[5] || 0), +(us[6] || 0)).getTime() || 0
  );
}

// ── Human-readable timestamp ──────────────────────────────────
export function formatTs(ts) {
  if (!ts) return "—";
  const ms = tsToMillis(ts);
  if (!ms) return String(ts);
  const d   = new Date(ms);
  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getDate())}/${pad(d.getMonth() + 1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

// ── Generic comparator (number-aware) ────────────────────────
export function cmp(a, b) {
  const an = Number(a), bn = Number(b);
  if (Number.isFinite(an) && Number.isFinite(bn)) return an - bn;
  return String(a ?? "").toLowerCase() < String(b ?? "").toLowerCase() ? -1 : 1;
}

// ── Deterministic pastel colour from a name string ───────────
export function hashInt(str) {
  let h = 2166136261;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h  = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function hsl2hex(h, s, l) {
  s /= 100; l /= 100;
  const k = (n) => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = (n) =>
    Math.round(255 * (l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)))))
      .toString(16).padStart(2, "0");
  return `#${f(0)}${f(8)}${f(4)}`;
}

export const jurorBg  = (n) => hsl2hex(hashInt(n || "?") % 360, 55, 95);
export const jurorDot = (n) => hsl2hex(hashInt(n || "?") % 360, 65, 55);

// ── CSV export ────────────────────────────────────────────────
// UTF-8 BOM prefix makes Turkish characters render correctly in Excel.
// Column order matches the spec: Juror Name, Dept, Timestamp, Group Name,
// Group Desc, Students, Technical (30), Written (30), Oral (30),
// Teamwork (10), Total (100), Comments.
export function exportCSV(rows) {
  const headers = [
    "Juror Name", "Department / Institution", "Timestamp",
    "Group Name", "Group Desc", "Students",
    "Technical (30)", "Written (30)", "Oral (30)", "Teamwork (10)",
    "Total (100)", "Comments",
  ];

  // Escape a value for CSV: wrap in quotes if it contains commas,
  // quotes, or newlines. Normalise CR+LF to LF first.
  const esc = (v) => {
    const s = String(v ?? "").replace(/\r\n|\r/g, "\n");
    return s.includes(",") || s.includes('"') || s.includes("\n")
      ? `"${s.replace(/"/g, '""')}"` : s;
  };

  const lines = [
    headers.map(esc).join(","),
    ...rows.map((r) => {
      const grp = PROJECT_MAP.get(r.projectId) || { desc: "", students: [] };
      return [
        r.juryName,
        r.juryDept,
        r.timestamp,
        r.projectName,
        grp.desc,
        grp.students.join(" · "),
        r.technical,
        r.design,
        r.delivery,
        r.teamwork,
        r.total,
        r.comments,
      ].map(esc).join(",");
    }),
  ];

  const now  = new Date();
  const date = now.toISOString().slice(0, 10);
  const hhmm = `${String(now.getHours()).padStart(2, "0")}-${String(now.getMinutes()).padStart(2, "0")}`;

  const blob = new Blob(["\uFEFF" + lines.join("\n")], {
    type: "text/csv;charset=utf-8;",
  });
  const url = URL.createObjectURL(blob);
  Object.assign(document.createElement("a"), {
    href:     url,
    download: `jury_export_${date}_${hhmm}.csv`,
  }).click();
  URL.revokeObjectURL(url);
}

// ── Completion % — mirrors countFilled / totalFields in useJuryState ─────────
// r[c.id] > 0 matches admin field names (technical/design/delivery/teamwork)
// which equal CRITERIA ids. 0 == not filled (toNum default).
export const countAdminFilledCriteria = (rows) =>
  rows.reduce((t, r) => t + CRITERIA.filter((c) => r[c.id] > 0).length, 0);

export const adminCompletionPct = (rows) => {
  const total = PROJECTS.length * CRITERIA.length;
  return total === 0 ? 0 : Math.round((countAdminFilledCriteria(rows) / total) * 100);
};

// ── Row deduplication ─────────────────────────────────────────
// Keeps the single best row per (juror + dept + group) composite key.
// "Best" = latest timestamp, with status priority as tiebreaker.
export function dedupeAndSort(rows) {
  const priority = { all_submitted: 3, group_submitted: 2, in_progress: 1 };

  const cleaned = (rows || [])
    .filter((r) => r?.juryName || r?.projectName || (r?.total ?? 0) > 0)
    .map((r) => ({
      ...r,
      tsMs: Number.isFinite(r?.tsMs) ? r.tsMs : tsToMillis(r?.timestamp),
    }));

  const byKey = new Map();

  for (const r of cleaned) {
    const jur = String(r.juryName ?? "").trim().toLowerCase();
    const dep = String(r.juryDept ?? "").trim().toLowerCase();
    const grp = r.projectId
      ? String(r.projectId).trim()
      : String(r.projectName ?? "").trim().toLowerCase();

    if (!jur || !grp) continue;
    const key  = `${jur}__${dep}__${grp}`;
    const prev = byKey.get(key);

    if (!prev) { byKey.set(key, r); continue; }

    // Prefer newer timestamp.
    if ((r.tsMs || 0) > (prev.tsMs || 0)) { byKey.set(key, r); continue; }
    // Same timestamp: prefer higher-priority status.
    if (
      (r.tsMs || 0) === (prev.tsMs || 0) &&
      (priority[r.status] || 0) > (priority[prev.status] || 0)
    ) {
      byKey.set(key, r);
    }
  }

  return [...byKey.values()].sort((a, b) => (b.tsMs || 0) - (a.tsMs || 0));
}
